package gdGenerator

import (
	"errors"
	"os"
	"strings"

	"github.com/ALiwoto/ssg/ssg"
	"github.com/ccl-lang/ccl/src/core/cclErrors"
	"github.com/ccl-lang/ccl/src/core/cclValues"
)

func (c *GDScriptGenerationContext) GenerateCode() error {
	c.ModelClasses = make(map[string]*strings.Builder)

	// Generate each model class
	for i := range c.Options.CCLDefinition.Models {
		model := c.Options.CCLDefinition.Models[i]
		err := c.GenerateModelClass(model)
		if err != nil {
			return err
		}

		// Get the builder for this model
		builder := c.ModelClasses[model.Name]
		if builder == nil {
			return errors.New("GenerateCode: Unexpected error: model class builder not found after generation")
		}

		// Generate methods
		c.generateSerializeMethod(model, builder)
		c.generateDeserializeMethod(model, builder)

		path := c.Options.OutputPath + string(os.PathSeparator)
		fileName := ToPascalCase(model.Name) + ".gd"
		err = ssg.WriteFileStr(path+fileName, builder.String())
		if err != nil {
			return err
		}

		// to not lack memory, we should delete the builder
		delete(c.ModelClasses, model.Name)
	}

	return nil
}

func (c *GDScriptGenerationContext) GenerateModelClass(model *CCLModel) error {
	builder := &strings.Builder{}
	c.ModelClasses[model.Name] = builder

	// Write class header
	builder.WriteString("# THIS FILE IS AUTOGENERATED BY A CCL TOOL. DO NOT EDIT.\n\n")
	builder.WriteString("class_name " + model.Name + "\n\n")

	// Write model ID constant
	modelIdConstName := "MODEL_ID_" + strings.ToUpper(ToSnakeCase(model.Name))
	builder.WriteString("const " + modelIdConstName +
		" = " + ssg.ToBase10(model.ModelId) + "\n\n")

	// Write class variables
	for _, field := range model.Fields {
		varType := c.getGDScriptType(field)
		if varType == "" {
			return &cclErrors.UnsupportedFieldTypeError{
				TypeName:       field.Type.GetName(),
				FieldName:      field.Name,
				ModelName:      field.Name,
				TargetLanguage: LanguageName,
			}
		}
		builder.WriteString("var " + ToSnakeCase(field.Name) + ": " + varType + "\n")
	}
	builder.WriteString("\n")

	// Add get_model_id method
	builder.WriteString("func get_model_id() -> int:\n")
	builder.WriteString("\treturn " + modelIdConstName + "\n\n")

	// Add clone_empty method
	builder.WriteString("func clone_empty() -> " + model.Name + ":\n")
	builder.WriteString("\treturn " + model.Name + ".new()\n\n")

	return nil
}

func (c *GDScriptGenerationContext) generateSerializeMethod(model *CCLModel, builder *strings.Builder) error {
	builder.WriteString("func serialize() -> PackedByteArray:\n")
	builder.WriteString("\tvar buffer = StreamPeerBuffer.new()\n\n")

	for i := range model.Fields {
		field := model.Fields[i]
		if field.IsArray() {
			c.generateArraySerialize(field, builder)
			continue
		}

		c.generateFieldSerialize(field, builder)
	}

	builder.WriteString("\treturn buffer.data_array\n\n")

	return nil
}

func (c *GDScriptGenerationContext) generateFieldSerialize(field *CCLField, builder *strings.Builder) {
	fieldName := ToSnakeCase(field.Name)
	switch field.Type.GetName() {
	case cclValues.TypeNameString:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u32(" + fieldName + ".length())\n")
		builder.WriteString("\tbuffer.put_data(" + fieldName + ".to_utf8_buffer())\n\n")
	case cclValues.TypeNameInt, cclValues.TypeNameInt32:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_32(" + fieldName + ")\n\n")
	case cclValues.TypeNameInt8:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_8(" + fieldName + ")\n\n")
	case cclValues.TypeNameInt16:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_16(" + fieldName + ")\n\n")
	case cclValues.TypeNameInt64:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_64(" + fieldName + ")\n\n")
	case cclValues.TypeNameUint, cclValues.TypeNameUint32:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u32(" + fieldName + ")\n\n")
	case cclValues.TypeNameUint8:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u8(" + fieldName + ")\n\n")
	case cclValues.TypeNameUint16:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u16(" + fieldName + ")\n\n")
	case cclValues.TypeNameUint64:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u64(" + fieldName + ")\n\n")
	case cclValues.TypeNameFloat, cclValues.TypeNameFloat32, cclValues.TypeNameFloat64:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_float(" + fieldName + ")\n\n")
	case cclValues.TypeNameBool:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_8(1 if " + fieldName + " else 0)\n\n")
	case cclValues.TypeNameBytes:
		builder.WriteString("\t# Write " + fieldName + "\n")
		builder.WriteString("\tbuffer.put_u32(" + fieldName + ".size())\n")
		builder.WriteString("\tbuffer.put_data(" + fieldName + ")\n\n")
	case cclValues.TypeNameDateTime:
		builder.WriteString("\t# Write " + fieldName + " as unix timestamp\n")
		builder.WriteString("\tbuffer.put_64(" + fieldName + ")\n\n")
	default:
		// Custom type handling
		if c.Options.CCLDefinition.IsCustomType(field.Type.GetName()) {
			builder.WriteString("\t# Write custom type " + fieldName + "\n")
			builder.WriteString("\tvar " + fieldName + "_bytes = " +
				fieldName + ".serialize() if " + fieldName + " else PackedByteArray([0])\n")
			builder.WriteString("\tbuffer.put_u32(" + fieldName + "_bytes.size())\n")
			builder.WriteString("\tbuffer.put_data(" + fieldName + "_bytes)\n\n")
		}
	}
}

func (c *GDScriptGenerationContext) generateArraySerialize(field *CCLField, builder *strings.Builder) {
	fieldName := ToSnakeCase(field.Name)
	builder.WriteString("\t# Write array " + fieldName + "\n")
	builder.WriteString("\tbuffer.put_u32(" + fieldName + ".size())\n")
	builder.WriteString("\tfor item in " + fieldName + ":\n")

	switch field.Type.GetName() {
	case cclValues.TypeNameString:
		builder.WriteString("\t\tbuffer.put_u32(item.length())\n")
		builder.WriteString("\t\tbuffer.put_data(item.to_utf8_buffer())\n")
	case cclValues.TypeNameInt, cclValues.TypeNameInt32:
		builder.WriteString("\t\tbuffer.put_32(item)\n")
	case cclValues.TypeNameInt8:
		builder.WriteString("\t\tbuffer.put_8(item)\n")
	case cclValues.TypeNameInt16:
		builder.WriteString("\t\tbuffer.put_16(item)\n")
	case cclValues.TypeNameInt64:
		builder.WriteString("\t\tbuffer.put_64(item)\n")
	case cclValues.TypeNameUint, cclValues.TypeNameUint32:
		builder.WriteString("\t\tbuffer.put_u32(item)\n")
	case cclValues.TypeNameUint8:
		builder.WriteString("\t\tbuffer.put_u8(item)\n")
	case cclValues.TypeNameUint16:
		builder.WriteString("\t\tbuffer.put_u16(item)\n")
	case cclValues.TypeNameUint64:
		builder.WriteString("\t\tbuffer.put_u64(item)\n")
	case cclValues.TypeNameFloat, cclValues.TypeNameFloat32, cclValues.TypeNameFloat64:
		builder.WriteString("\t\tbuffer.put_float(item)\n")
	case cclValues.TypeNameBool:
		builder.WriteString("\t\tbuffer.put_8(1 if item else 0)\n")
	default:
		if c.Options.CCLDefinition.IsCustomType(field.Type.GetName()) {
			builder.WriteString("\t\tvar item_bytes = item.serialize() if item else PackedByteArray([0])\n")
			builder.WriteString("\t\tbuffer.put_u32(item_bytes.size())\n")
			builder.WriteString("\t\tbuffer.put_data(item_bytes)\n")
		}
	}
	builder.WriteString("\n")
}

func (c *GDScriptGenerationContext) generateDeserializeMethod(model *CCLModel, builder *strings.Builder) {
	builder.WriteString("static func deserialize(data: PackedByteArray) -> " + model.Name + ":\n")

	// null-safety check
	builder.WriteString("\tif not data or data.is_empty() or (data.size() == 1 and data[1] == 0):\n")
	builder.WriteString("\t\treturn null\n\n")

	builder.WriteString("\tvar buffer = StreamPeerBuffer.new()\n")
	builder.WriteString("\tbuffer.data_array = data\n")
	builder.WriteString("\tvar result = " + model.Name + ".new()\n\n")

	for _, field := range model.Fields {
		if field.IsArray() {
			c.generateArrayDeserialize(field, builder)
			continue
		}

		c.generateFieldDeserialize(field, builder)
	}

	builder.WriteString("\treturn result\n")
}

func (c *GDScriptGenerationContext) generateFieldDeserialize(field *CCLField, builder *strings.Builder) {
	fieldName := ToSnakeCase(field.Name)
	builder.WriteString("\t# Read " + fieldName + "\n")
	switch field.Type.GetName() {
	case cclValues.TypeNameString:
		builder.WriteString("\t# Read " + fieldName + "\n")
		builder.WriteString("\tvar " + fieldName + "_len = buffer.get_u32()\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_data(" +
			fieldName + "_len)[1].get_string_from_utf8()\n\n")
	case cclValues.TypeNameInt, cclValues.TypeNameInt32:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_32()\n\n")
	case cclValues.TypeNameInt8:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_8()\n\n")
	case cclValues.TypeNameInt16:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_16()\n\n")
	case cclValues.TypeNameInt64:
		builder.WriteString("\t# Read " + fieldName + "\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_64()\n\n")
	case cclValues.TypeNameUint, cclValues.TypeNameUint32:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_u32()\n\n")
	case cclValues.TypeNameUint8:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_u8()\n\n")
	case cclValues.TypeNameUint16:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_u16()\n\n")
	case cclValues.TypeNameUint64:
		builder.WriteString("\tresult." + fieldName + " = buffer.get_u64()\n\n")
	case cclValues.TypeNameFloat, cclValues.TypeNameFloat32, cclValues.TypeNameFloat64:
		builder.WriteString("\t# Read " + fieldName + "\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_float()\n\n")
	case cclValues.TypeNameBool:
		builder.WriteString("\t# Read " + fieldName + "\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_8() != 0\n\n")
	case cclValues.TypeNameBytes:
		builder.WriteString("\t# Read " + fieldName + "\n")
		builder.WriteString("\tvar " + fieldName + "_len = buffer.get_u32()\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_data(" +
			fieldName + "_len)[1]\n\n")
	case cclValues.TypeNameDateTime:
		builder.WriteString("\t# Read " + fieldName + " timestamp\n")
		builder.WriteString("\tresult." + fieldName + " = buffer.get_64()\n\n")
	default:
		// Custom type handling
		if c.Options.CCLDefinition.IsCustomType(field.Type.GetName()) {
			builder.WriteString("\t# Read custom type " + fieldName + "\n")
			builder.WriteString("\tvar " + fieldName + "_len = buffer.get_u32()\n")
			builder.WriteString("\tvar " + fieldName + "_bytes = buffer.get_data(" +
				fieldName + "_len)[1]\n")
			builder.WriteString("\tresult." + fieldName + " = " + field.Type.GetName() +
				".deserialize(" + fieldName + "_bytes)\n\n")
		}
	}
}

func (c *GDScriptGenerationContext) generateArrayDeserialize(field *CCLField, builder *strings.Builder) {
	fieldName := ToSnakeCase(field.Name)
	builder.WriteString("\t# Read array " + fieldName + "\n")
	builder.WriteString("\tvar " + fieldName + "_len = buffer.get_u32()\n")
	builder.WriteString("\tresult." + fieldName + " = []\n")
	builder.WriteString("\tfor i in range(" + fieldName + "_len):\n")

	switch field.Type.GetName() {
	case cclValues.TypeNameString:
		builder.WriteString("\t\tvar item_len = buffer.get_u32()\n")
		builder.WriteString("\t\tvar item = buffer.get_data(item_len)[1].get_string_from_utf8()\n")
		builder.WriteString("\t\tresult." + fieldName + ".append(item)\n")
	case cclValues.TypeNameInt, cclValues.TypeNameInt32:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_32())\n")
	case cclValues.TypeNameInt8:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_8())\n")
	case cclValues.TypeNameInt16:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_16())\n")
	case cclValues.TypeNameInt64:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_64())\n")
	case cclValues.TypeNameUint, cclValues.TypeNameUint32:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_u32())\n")
	case cclValues.TypeNameUint8:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_u8())\n")
	case cclValues.TypeNameUint16:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_u16())\n")
	case cclValues.TypeNameUint64:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_u64())\n")
	case cclValues.TypeNameFloat, cclValues.TypeNameFloat32, cclValues.TypeNameFloat64:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_float())\n")
	case cclValues.TypeNameBool:
		builder.WriteString("\t\tresult." + fieldName + ".append(buffer.get_8() != 0)\n")
	default:
		if c.Options.CCLDefinition.IsCustomType(field.Type.GetName()) {
			builder.WriteString("\t\tvar item_len = buffer.get_u32()\n")
			builder.WriteString("\t\tvar item_bytes = buffer.get_data(item_len)[1]\n")
			builder.WriteString("\t\tresult." + fieldName + ".append(" +
				field.Type.GetName() + ".deserialize(item_bytes))\n")
		}
	}
	builder.WriteString("\n")
}

func (c *GDScriptGenerationContext) IsCustomType(cclType string) bool {
	return c.Options.CCLDefinition.IsCustomType(cclType)
}

func (c *GDScriptGenerationContext) getGDScriptType(field *cclValues.FieldDefinition) string {
	fieldTypeName := field.Type.GetName()
	gdType := CCLTypesToGdTypes[fieldTypeName]
	if gdType == "" {
		if !c.IsCustomType(fieldTypeName) {
			return ""
		}

		gdType = fieldTypeName
	}

	if field.IsArray() {
		gdType = "Array[" + gdType + "]"
	}

	return gdType
}
